/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package humorapi.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import humorapi.models.AnalyzeJoke200Response
import humorapi.models.RandomJoke200Response
import humorapi.models.SearchJokes200Response
import humorapi.models.SubmitJoke200Response

import com.squareup.moshi.Json

import humorapi.infrastructure.ApiClient
import humorapi.infrastructure.ApiResponse
import humorapi.infrastructure.ClientException
import humorapi.infrastructure.ClientError
import humorapi.infrastructure.ServerException
import humorapi.infrastructure.ServerError
import humorapi.infrastructure.MultiValueMap
import humorapi.infrastructure.PartConfig
import humorapi.infrastructure.RequestConfig
import humorapi.infrastructure.RequestMethod
import humorapi.infrastructure.ResponseType
import humorapi.infrastructure.Success
import humorapi.infrastructure.toMultiValue

class JokesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.humorapi.com")
        }
    }

    /**
     * Analyze Joke
     * Analyze a joke. See https://humorapi.com/docs/#Analyze-Joke for more.
     * @param body Post the joke as plain text. (optional)
     * @return AnalyzeJoke200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun analyzeJoke(body: kotlin.String? = null) : AnalyzeJoke200Response {
        val localVarResponse = analyzeJokeWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnalyzeJoke200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Analyze Joke
     * Analyze a joke. See https://humorapi.com/docs/#Analyze-Joke for more.
     * @param body Post the joke as plain text. (optional)
     * @return ApiResponse<AnalyzeJoke200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun analyzeJokeWithHttpInfo(body: kotlin.String?) : ApiResponse<AnalyzeJoke200Response?> {
        val localVariableConfig = analyzeJokeRequestConfig(body = body)

        return request<kotlin.String, AnalyzeJoke200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation analyzeJoke
     *
     * @param body Post the joke as plain text. (optional)
     * @return RequestConfig
     */
    fun analyzeJokeRequestConfig(body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/jokes/analyze",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Downvote a Joke
     * Downvote a joke. See https://humorapi.com/docs/#Downvote-Joke for more.
     * @param id The object&#39;s id.
     * @return SubmitJoke200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun downvoteJoke(id: kotlin.Int) : SubmitJoke200Response {
        val localVarResponse = downvoteJokeWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubmitJoke200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Downvote a Joke
     * Downvote a joke. See https://humorapi.com/docs/#Downvote-Joke for more.
     * @param id The object&#39;s id.
     * @return ApiResponse<SubmitJoke200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun downvoteJokeWithHttpInfo(id: kotlin.Int) : ApiResponse<SubmitJoke200Response?> {
        val localVariableConfig = downvoteJokeRequestConfig(id = id)

        return request<Unit, SubmitJoke200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation downvoteJoke
     *
     * @param id The object&#39;s id.
     * @return RequestConfig
     */
    fun downvoteJokeRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/jokes/{id}/downvote".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter includeTags
     */
     enum class IncludeTagsRandomJoke(val value: kotlin.String) {
         @Json(name = "clean") clean("clean"),
         @Json(name = "yo_mama") yoMama("yo_mama"),
         @Json(name = "chuck_norris") chuckNorris("chuck_norris"),
         @Json(name = "nsfw") nsfw("nsfw"),
         @Json(name = "racist") racist("racist"),
         @Json(name = "sexist") sexist("sexist"),
         @Json(name = "sexual") sexual("sexual"),
         @Json(name = "political") political("political"),
         @Json(name = "religious") religious("religious"),
         @Json(name = "knock_knock") knockKnock("knock_knock"),
         @Json(name = "christmas") christmas("christmas"),
         @Json(name = "nerdy") nerdy("nerdy"),
         @Json(name = "analogy") analogy("analogy"),
         @Json(name = "one_liner") oneLiner("one_liner"),
         @Json(name = "dark") dark("dark"),
         @Json(name = "jewish") jewish("jewish"),
         @Json(name = "school") school("school"),
         @Json(name = "sport") sport("sport"),
         @Json(name = "law") law("law"),
         @Json(name = "kids") kids("kids"),
         @Json(name = "animal") animal("animal"),
         @Json(name = "relationship") relationship("relationship"),
         @Json(name = "insults") insults("insults"),
         @Json(name = "blondes") blondes("blondes"),
         @Json(name = "deep_thoughts") deepThoughts("deep_thoughts"),
         @Json(name = "food") food("food"),
         @Json(name = "holiday") holiday("holiday")
     }

    /**
     * enum for parameter excludeTags
     */
     enum class ExcludeTagsRandomJoke(val value: kotlin.String) {
         @Json(name = "clean") clean("clean"),
         @Json(name = "yo_mama") yoMama("yo_mama"),
         @Json(name = "chuck_norris") chuckNorris("chuck_norris"),
         @Json(name = "nsfw") nsfw("nsfw"),
         @Json(name = "racist") racist("racist"),
         @Json(name = "sexist") sexist("sexist"),
         @Json(name = "sexual") sexual("sexual"),
         @Json(name = "political") political("political"),
         @Json(name = "religious") religious("religious"),
         @Json(name = "knock_knock") knockKnock("knock_knock"),
         @Json(name = "christmas") christmas("christmas"),
         @Json(name = "nerdy") nerdy("nerdy"),
         @Json(name = "analogy") analogy("analogy"),
         @Json(name = "one_liner") oneLiner("one_liner"),
         @Json(name = "dark") dark("dark"),
         @Json(name = "jewish") jewish("jewish"),
         @Json(name = "school") school("school"),
         @Json(name = "sport") sport("sport"),
         @Json(name = "law") law("law"),
         @Json(name = "kids") kids("kids"),
         @Json(name = "animal") animal("animal"),
         @Json(name = "relationship") relationship("relationship"),
         @Json(name = "insults") insults("insults"),
         @Json(name = "blondes") blondes("blondes"),
         @Json(name = "deep_thoughts") deepThoughts("deep_thoughts"),
         @Json(name = "food") food("food"),
         @Json(name = "holiday") holiday("holiday")
     }

    /**
     * Random Joke
     * Get a random joke. See https://humorapi.com/docs/#Random-Joke for more.
     * @param keywords A comma separated list of keywords. (optional)
     * @param includeTags A comma separated list of tags that the joke must have. (optional)
     * @param excludeTags A comma separated list of tags that the joke must not have. (optional)
     * @param minRating The minimum rating between 0 and 10 the result should have. (optional)
     * @param maxLength The maximum number of letters in the joke. (optional)
     * @return RandomJoke200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun randomJoke(keywords: kotlin.String? = null, includeTags: IncludeTagsRandomJoke? = null, excludeTags: ExcludeTagsRandomJoke? = null, minRating: kotlin.Int? = null, maxLength: kotlin.Int? = null) : RandomJoke200Response {
        val localVarResponse = randomJokeWithHttpInfo(keywords = keywords, includeTags = includeTags, excludeTags = excludeTags, minRating = minRating, maxLength = maxLength)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RandomJoke200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Random Joke
     * Get a random joke. See https://humorapi.com/docs/#Random-Joke for more.
     * @param keywords A comma separated list of keywords. (optional)
     * @param includeTags A comma separated list of tags that the joke must have. (optional)
     * @param excludeTags A comma separated list of tags that the joke must not have. (optional)
     * @param minRating The minimum rating between 0 and 10 the result should have. (optional)
     * @param maxLength The maximum number of letters in the joke. (optional)
     * @return ApiResponse<RandomJoke200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun randomJokeWithHttpInfo(keywords: kotlin.String?, includeTags: IncludeTagsRandomJoke?, excludeTags: ExcludeTagsRandomJoke?, minRating: kotlin.Int?, maxLength: kotlin.Int?) : ApiResponse<RandomJoke200Response?> {
        val localVariableConfig = randomJokeRequestConfig(keywords = keywords, includeTags = includeTags, excludeTags = excludeTags, minRating = minRating, maxLength = maxLength)

        return request<Unit, RandomJoke200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation randomJoke
     *
     * @param keywords A comma separated list of keywords. (optional)
     * @param includeTags A comma separated list of tags that the joke must have. (optional)
     * @param excludeTags A comma separated list of tags that the joke must not have. (optional)
     * @param minRating The minimum rating between 0 and 10 the result should have. (optional)
     * @param maxLength The maximum number of letters in the joke. (optional)
     * @return RequestConfig
     */
    fun randomJokeRequestConfig(keywords: kotlin.String?, includeTags: IncludeTagsRandomJoke?, excludeTags: ExcludeTagsRandomJoke?, minRating: kotlin.Int?, maxLength: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (keywords != null) {
                    put("keywords", listOf(keywords.toString()))
                }
                if (includeTags != null) {
                    put("include-tags", listOf(includeTags.value))
                }
                if (excludeTags != null) {
                    put("exclude-tags", listOf(excludeTags.value))
                }
                if (minRating != null) {
                    put("min-rating", listOf(minRating.toString()))
                }
                if (maxLength != null) {
                    put("max-length", listOf(maxLength.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/jokes/random",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter includeTags
     */
     enum class IncludeTagsSearchJokes(val value: kotlin.String) {
         @Json(name = "clean") clean("clean"),
         @Json(name = "yo_mama") yoMama("yo_mama"),
         @Json(name = "chuck_norris") chuckNorris("chuck_norris"),
         @Json(name = "nsfw") nsfw("nsfw"),
         @Json(name = "racist") racist("racist"),
         @Json(name = "sexist") sexist("sexist"),
         @Json(name = "sexual") sexual("sexual"),
         @Json(name = "political") political("political"),
         @Json(name = "religious") religious("religious"),
         @Json(name = "knock_knock") knockKnock("knock_knock"),
         @Json(name = "christmas") christmas("christmas"),
         @Json(name = "nerdy") nerdy("nerdy"),
         @Json(name = "analogy") analogy("analogy"),
         @Json(name = "one_liner") oneLiner("one_liner"),
         @Json(name = "dark") dark("dark"),
         @Json(name = "jewish") jewish("jewish"),
         @Json(name = "school") school("school"),
         @Json(name = "sport") sport("sport"),
         @Json(name = "law") law("law"),
         @Json(name = "kids") kids("kids"),
         @Json(name = "animal") animal("animal"),
         @Json(name = "relationship") relationship("relationship"),
         @Json(name = "insults") insults("insults"),
         @Json(name = "blondes") blondes("blondes"),
         @Json(name = "deep_thoughts") deepThoughts("deep_thoughts"),
         @Json(name = "food") food("food"),
         @Json(name = "holiday") holiday("holiday")
     }

    /**
     * enum for parameter excludeTags
     */
     enum class ExcludeTagsSearchJokes(val value: kotlin.String) {
         @Json(name = "clean") clean("clean"),
         @Json(name = "yo_mama") yoMama("yo_mama"),
         @Json(name = "chuck_norris") chuckNorris("chuck_norris"),
         @Json(name = "nsfw") nsfw("nsfw"),
         @Json(name = "racist") racist("racist"),
         @Json(name = "sexist") sexist("sexist"),
         @Json(name = "sexual") sexual("sexual"),
         @Json(name = "political") political("political"),
         @Json(name = "religious") religious("religious"),
         @Json(name = "knock_knock") knockKnock("knock_knock"),
         @Json(name = "christmas") christmas("christmas"),
         @Json(name = "nerdy") nerdy("nerdy"),
         @Json(name = "analogy") analogy("analogy"),
         @Json(name = "one_liner") oneLiner("one_liner"),
         @Json(name = "dark") dark("dark"),
         @Json(name = "jewish") jewish("jewish"),
         @Json(name = "school") school("school"),
         @Json(name = "sport") sport("sport"),
         @Json(name = "law") law("law"),
         @Json(name = "kids") kids("kids"),
         @Json(name = "animal") animal("animal"),
         @Json(name = "relationship") relationship("relationship"),
         @Json(name = "insults") insults("insults"),
         @Json(name = "blondes") blondes("blondes"),
         @Json(name = "deep_thoughts") deepThoughts("deep_thoughts"),
         @Json(name = "food") food("food"),
         @Json(name = "holiday") holiday("holiday")
     }

    /**
     * Search Jokes
     * Search for jokes. See https://humorapi.com/docs/#Search-Jokes for more.
     * @param keywords A comma separated list of keywords. (optional)
     * @param includeTags A comma separated list of tags that the joke must have. (optional)
     * @param excludeTags A comma separated list of tags that the joke must not have. (optional)
     * @param number The number of results to retrieve between 1 and 10. (optional)
     * @param minRating The minimum rating between 0 and 10 the result should have. (optional)
     * @param maxLength The maximum number of letters in the joke. (optional)
     * @param offset The number of results to skip. (optional)
     * @return SearchJokes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchJokes(keywords: kotlin.String? = null, includeTags: IncludeTagsSearchJokes? = null, excludeTags: ExcludeTagsSearchJokes? = null, number: kotlin.Int? = null, minRating: kotlin.Int? = null, maxLength: kotlin.Int? = null, offset: java.math.BigDecimal? = null) : SearchJokes200Response {
        val localVarResponse = searchJokesWithHttpInfo(keywords = keywords, includeTags = includeTags, excludeTags = excludeTags, number = number, minRating = minRating, maxLength = maxLength, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchJokes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Search Jokes
     * Search for jokes. See https://humorapi.com/docs/#Search-Jokes for more.
     * @param keywords A comma separated list of keywords. (optional)
     * @param includeTags A comma separated list of tags that the joke must have. (optional)
     * @param excludeTags A comma separated list of tags that the joke must not have. (optional)
     * @param number The number of results to retrieve between 1 and 10. (optional)
     * @param minRating The minimum rating between 0 and 10 the result should have. (optional)
     * @param maxLength The maximum number of letters in the joke. (optional)
     * @param offset The number of results to skip. (optional)
     * @return ApiResponse<SearchJokes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchJokesWithHttpInfo(keywords: kotlin.String?, includeTags: IncludeTagsSearchJokes?, excludeTags: ExcludeTagsSearchJokes?, number: kotlin.Int?, minRating: kotlin.Int?, maxLength: kotlin.Int?, offset: java.math.BigDecimal?) : ApiResponse<SearchJokes200Response?> {
        val localVariableConfig = searchJokesRequestConfig(keywords = keywords, includeTags = includeTags, excludeTags = excludeTags, number = number, minRating = minRating, maxLength = maxLength, offset = offset)

        return request<Unit, SearchJokes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchJokes
     *
     * @param keywords A comma separated list of keywords. (optional)
     * @param includeTags A comma separated list of tags that the joke must have. (optional)
     * @param excludeTags A comma separated list of tags that the joke must not have. (optional)
     * @param number The number of results to retrieve between 1 and 10. (optional)
     * @param minRating The minimum rating between 0 and 10 the result should have. (optional)
     * @param maxLength The maximum number of letters in the joke. (optional)
     * @param offset The number of results to skip. (optional)
     * @return RequestConfig
     */
    fun searchJokesRequestConfig(keywords: kotlin.String?, includeTags: IncludeTagsSearchJokes?, excludeTags: ExcludeTagsSearchJokes?, number: kotlin.Int?, minRating: kotlin.Int?, maxLength: kotlin.Int?, offset: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (keywords != null) {
                    put("keywords", listOf(keywords.toString()))
                }
                if (includeTags != null) {
                    put("include-tags", listOf(includeTags.value))
                }
                if (excludeTags != null) {
                    put("exclude-tags", listOf(excludeTags.value))
                }
                if (number != null) {
                    put("number", listOf(number.toString()))
                }
                if (minRating != null) {
                    put("min-rating", listOf(minRating.toString()))
                }
                if (maxLength != null) {
                    put("max-length", listOf(maxLength.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/jokes/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Submit Joke
     * Submit a joke. See https://humorapi.com/docs/#Submit-Joke for more.
     * @param body Post the joke as plain text. (optional)
     * @return SubmitJoke200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun submitJoke(body: kotlin.String? = null) : SubmitJoke200Response {
        val localVarResponse = submitJokeWithHttpInfo(body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubmitJoke200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Submit Joke
     * Submit a joke. See https://humorapi.com/docs/#Submit-Joke for more.
     * @param body Post the joke as plain text. (optional)
     * @return ApiResponse<SubmitJoke200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun submitJokeWithHttpInfo(body: kotlin.String?) : ApiResponse<SubmitJoke200Response?> {
        val localVariableConfig = submitJokeRequestConfig(body = body)

        return request<kotlin.String, SubmitJoke200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation submitJoke
     *
     * @param body Post the joke as plain text. (optional)
     * @return RequestConfig
     */
    fun submitJokeRequestConfig(body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/jokes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Upvote a Joke
     * Upvote a joke. See https://humorapi.com/docs/#Upvote-Joke for more.
     * @param id The object&#39;s id.
     * @return SubmitJoke200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun upvoteJoke(id: kotlin.Int) : SubmitJoke200Response {
        val localVarResponse = upvoteJokeWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SubmitJoke200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upvote a Joke
     * Upvote a joke. See https://humorapi.com/docs/#Upvote-Joke for more.
     * @param id The object&#39;s id.
     * @return ApiResponse<SubmitJoke200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun upvoteJokeWithHttpInfo(id: kotlin.Int) : ApiResponse<SubmitJoke200Response?> {
        val localVariableConfig = upvoteJokeRequestConfig(id = id)

        return request<Unit, SubmitJoke200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation upvoteJoke
     *
     * @param id The object&#39;s id.
     * @return RequestConfig
     */
    fun upvoteJokeRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/jokes/{id}/upvote".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
