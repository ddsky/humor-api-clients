{-
   Humor API

   Awesome Humor API.

   OpenAPI Version: 3.0.0
   Humor API API version: 1.0
   Contact: mail@humorapi.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Humor.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Humor.Model where

import Humor.Core
import Humor.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ExcludeTags
newtype ExcludeTags = ExcludeTags { unExcludeTags :: E'IncludeTags } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IncludeTags
newtype IncludeTags = IncludeTags { unIncludeTags :: E'IncludeTags } deriving (P.Eq, P.Show)

-- ** Keywords
newtype Keywords = Keywords { unKeywords :: Text } deriving (P.Eq, P.Show)

-- ** KeywordsInImage
newtype KeywordsInImage = KeywordsInImage { unKeywordsInImage :: E'KeywordsInImage } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Int } deriving (P.Eq, P.Show)

-- ** MediaType
newtype MediaType = MediaType { unMediaType :: E'MediaType } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Double } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Reason
newtype Reason = Reason { unReason :: Text } deriving (P.Eq, P.Show)

-- ** Word
newtype Word = Word { unWord :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Jokes :: !([A.Value]) -- ^ /Required/ "jokes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:  "jokes")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "jokes" .= inlineResponse200Jokes
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: [A.Value] -- ^ 'inlineResponse200Jokes' 
  -> InlineResponse200
mkInlineResponse200 inlineResponse200Jokes =
  InlineResponse200
  { inlineResponse200Jokes
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001Images :: !([A.Value]) -- ^ /Required/ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:  "images")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "images" .= inlineResponse2001Images
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: [A.Value] -- ^ 'inlineResponse2001Images' 
  -> InlineResponse2001
mkInlineResponse2001 inlineResponse2001Images =
  InlineResponse2001
  { inlineResponse2001Images
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002Memes :: !([A.Value]) -- ^ /Required/ "memes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:  "memes")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "memes" .= inlineResponse2002Memes
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: [A.Value] -- ^ 'inlineResponse2002Memes' 
  -> InlineResponse2002
mkInlineResponse2002 inlineResponse2002Memes =
  InlineResponse2002
  { inlineResponse2002Memes
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2003Url :: !(Text) -- ^ /Required/ "url"
  , inlineResponse2003Type :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:  "id")
      <*> (o .:  "url")
      <*> (o .:  "type")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "id" .= inlineResponse2003Id
      , "url" .= inlineResponse2003Url
      , "type" .= inlineResponse2003Type
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: Int -- ^ 'inlineResponse2003Id' 
  -> Text -- ^ 'inlineResponse2003Url' 
  -> Text -- ^ 'inlineResponse2003Type' 
  -> InlineResponse2003
mkInlineResponse2003 inlineResponse2003Id inlineResponse2003Url inlineResponse2003Type =
  InlineResponse2003
  { inlineResponse2003Id
  , inlineResponse2003Url
  , inlineResponse2003Type
  }

-- ** InlineResponse2004
-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { inlineResponse2004Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2004Joke :: !(Text) -- ^ /Required/ "joke"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:  "id")
      <*> (o .:  "joke")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
   _omitNulls
      [ "id" .= inlineResponse2004Id
      , "joke" .= inlineResponse2004Joke
      ]


-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004
  :: Int -- ^ 'inlineResponse2004Id' 
  -> Text -- ^ 'inlineResponse2004Joke' 
  -> InlineResponse2004
mkInlineResponse2004 inlineResponse2004Id inlineResponse2004Joke =
  InlineResponse2004
  { inlineResponse2004Id
  , inlineResponse2004Joke
  }

-- ** InlineResponse2005
-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { inlineResponse2005Text :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:  "text")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
   _omitNulls
      [ "text" .= inlineResponse2005Text
      ]


-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005
  :: Text -- ^ 'inlineResponse2005Text' 
  -> InlineResponse2005
mkInlineResponse2005 inlineResponse2005Text =
  InlineResponse2005
  { inlineResponse2005Text
  }

-- ** InlineResponse2006
-- | InlineResponse2006
data InlineResponse2006 = InlineResponse2006
  { inlineResponse2006Rating :: !(Double) -- ^ /Required/ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:  "rating")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
   _omitNulls
      [ "rating" .= inlineResponse2006Rating
      ]


-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006
  :: Double -- ^ 'inlineResponse2006Rating' 
  -> InlineResponse2006
mkInlineResponse2006 inlineResponse2006Rating =
  InlineResponse2006
  { inlineResponse2006Rating
  }

-- ** InlineResponse2007
-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { inlineResponse2007Word :: !(Text) -- ^ /Required/ "word"
  , inlineResponse2007Rating :: !(Double) -- ^ /Required/ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:  "word")
      <*> (o .:  "rating")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
   _omitNulls
      [ "word" .= inlineResponse2007Word
      , "rating" .= inlineResponse2007Rating
      ]


-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007
  :: Text -- ^ 'inlineResponse2007Word' 
  -> Double -- ^ 'inlineResponse2007Rating' 
  -> InlineResponse2007
mkInlineResponse2007 inlineResponse2007Word inlineResponse2007Rating =
  InlineResponse2007
  { inlineResponse2007Word
  , inlineResponse2007Rating
  }

-- ** InlineResponse2008
-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { inlineResponse2008Message :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:  "message")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
   _omitNulls
      [ "message" .= inlineResponse2008Message
      ]


-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008
  :: Text -- ^ 'inlineResponse2008Message' 
  -> InlineResponse2008
mkInlineResponse2008 inlineResponse2008Message =
  InlineResponse2008
  { inlineResponse2008Message
  }

-- ** InlineResponse2009
-- | InlineResponse2009
data InlineResponse2009 = InlineResponse2009
  { inlineResponse2009Joke :: !(Text) -- ^ /Required/ "joke"
  , inlineResponse2009Tags :: !([Text]) -- ^ /Required/ "tags"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009
instance A.FromJSON InlineResponse2009 where
  parseJSON = A.withObject "InlineResponse2009" $ \o ->
    InlineResponse2009
      <$> (o .:  "joke")
      <*> (o .:  "tags")

-- | ToJSON InlineResponse2009
instance A.ToJSON InlineResponse2009 where
  toJSON InlineResponse2009 {..} =
   _omitNulls
      [ "joke" .= inlineResponse2009Joke
      , "tags" .= inlineResponse2009Tags
      ]


-- | Construct a value of type 'InlineResponse2009' (by applying it's required fields, if any)
mkInlineResponse2009
  :: Text -- ^ 'inlineResponse2009Joke' 
  -> [Text] -- ^ 'inlineResponse2009Tags' 
  -> InlineResponse2009
mkInlineResponse2009 inlineResponse2009Joke inlineResponse2009Tags =
  InlineResponse2009
  { inlineResponse2009Joke
  , inlineResponse2009Tags
  }


-- * Enums


-- ** E'IncludeTags

-- | Enum of 'Text'
data E'IncludeTags
  = E'IncludeTags'Clean -- ^ @"clean"@
  | E'IncludeTags'Yo_mama -- ^ @"yo_mama"@
  | E'IncludeTags'Chuck_norris -- ^ @"chuck_norris"@
  | E'IncludeTags'Nsfw -- ^ @"nsfw"@
  | E'IncludeTags'Racist -- ^ @"racist"@
  | E'IncludeTags'Sexist -- ^ @"sexist"@
  | E'IncludeTags'Sexual -- ^ @"sexual"@
  | E'IncludeTags'Political -- ^ @"political"@
  | E'IncludeTags'Religious -- ^ @"religious"@
  | E'IncludeTags'Knock_knock -- ^ @"knock_knock"@
  | E'IncludeTags'Christmas -- ^ @"christmas"@
  | E'IncludeTags'Nerdy -- ^ @"nerdy"@
  | E'IncludeTags'Analogy -- ^ @"analogy"@
  | E'IncludeTags'One_liner -- ^ @"one_liner"@
  | E'IncludeTags'Dark -- ^ @"dark"@
  | E'IncludeTags'Jewish -- ^ @"jewish"@
  | E'IncludeTags'School -- ^ @"school"@
  | E'IncludeTags'Sport -- ^ @"sport"@
  | E'IncludeTags'Law -- ^ @"law"@
  | E'IncludeTags'Kids -- ^ @"kids"@
  | E'IncludeTags'Animal -- ^ @"animal"@
  | E'IncludeTags'Relationship -- ^ @"relationship"@
  | E'IncludeTags'Insults -- ^ @"insults"@
  | E'IncludeTags'Blondes -- ^ @"blondes"@
  | E'IncludeTags'Deep_thoughts -- ^ @"deep_thoughts"@
  | E'IncludeTags'Food -- ^ @"food"@
  | E'IncludeTags'Holiday -- ^ @"holiday"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'IncludeTags where toJSON = A.toJSON . fromE'IncludeTags
instance A.FromJSON E'IncludeTags where parseJSON o = P.either P.fail (pure . P.id) . toE'IncludeTags =<< A.parseJSON o
instance WH.ToHttpApiData E'IncludeTags where toQueryParam = WH.toQueryParam . fromE'IncludeTags
instance WH.FromHttpApiData E'IncludeTags where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'IncludeTags
instance MimeRender MimeMultipartFormData E'IncludeTags where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'IncludeTags' enum
fromE'IncludeTags :: E'IncludeTags -> Text
fromE'IncludeTags = \case
  E'IncludeTags'Clean -> "clean"
  E'IncludeTags'Yo_mama -> "yo_mama"
  E'IncludeTags'Chuck_norris -> "chuck_norris"
  E'IncludeTags'Nsfw -> "nsfw"
  E'IncludeTags'Racist -> "racist"
  E'IncludeTags'Sexist -> "sexist"
  E'IncludeTags'Sexual -> "sexual"
  E'IncludeTags'Political -> "political"
  E'IncludeTags'Religious -> "religious"
  E'IncludeTags'Knock_knock -> "knock_knock"
  E'IncludeTags'Christmas -> "christmas"
  E'IncludeTags'Nerdy -> "nerdy"
  E'IncludeTags'Analogy -> "analogy"
  E'IncludeTags'One_liner -> "one_liner"
  E'IncludeTags'Dark -> "dark"
  E'IncludeTags'Jewish -> "jewish"
  E'IncludeTags'School -> "school"
  E'IncludeTags'Sport -> "sport"
  E'IncludeTags'Law -> "law"
  E'IncludeTags'Kids -> "kids"
  E'IncludeTags'Animal -> "animal"
  E'IncludeTags'Relationship -> "relationship"
  E'IncludeTags'Insults -> "insults"
  E'IncludeTags'Blondes -> "blondes"
  E'IncludeTags'Deep_thoughts -> "deep_thoughts"
  E'IncludeTags'Food -> "food"
  E'IncludeTags'Holiday -> "holiday"

-- | parse 'E'IncludeTags' enum
toE'IncludeTags :: Text -> P.Either String E'IncludeTags
toE'IncludeTags = \case
  "clean" -> P.Right E'IncludeTags'Clean
  "yo_mama" -> P.Right E'IncludeTags'Yo_mama
  "chuck_norris" -> P.Right E'IncludeTags'Chuck_norris
  "nsfw" -> P.Right E'IncludeTags'Nsfw
  "racist" -> P.Right E'IncludeTags'Racist
  "sexist" -> P.Right E'IncludeTags'Sexist
  "sexual" -> P.Right E'IncludeTags'Sexual
  "political" -> P.Right E'IncludeTags'Political
  "religious" -> P.Right E'IncludeTags'Religious
  "knock_knock" -> P.Right E'IncludeTags'Knock_knock
  "christmas" -> P.Right E'IncludeTags'Christmas
  "nerdy" -> P.Right E'IncludeTags'Nerdy
  "analogy" -> P.Right E'IncludeTags'Analogy
  "one_liner" -> P.Right E'IncludeTags'One_liner
  "dark" -> P.Right E'IncludeTags'Dark
  "jewish" -> P.Right E'IncludeTags'Jewish
  "school" -> P.Right E'IncludeTags'School
  "sport" -> P.Right E'IncludeTags'Sport
  "law" -> P.Right E'IncludeTags'Law
  "kids" -> P.Right E'IncludeTags'Kids
  "animal" -> P.Right E'IncludeTags'Animal
  "relationship" -> P.Right E'IncludeTags'Relationship
  "insults" -> P.Right E'IncludeTags'Insults
  "blondes" -> P.Right E'IncludeTags'Blondes
  "deep_thoughts" -> P.Right E'IncludeTags'Deep_thoughts
  "food" -> P.Right E'IncludeTags'Food
  "holiday" -> P.Right E'IncludeTags'Holiday
  s -> P.Left $ "toE'IncludeTags: enum parse failure: " P.++ P.show s


-- ** E'KeywordsInImage

-- | Enum of 'Bool'
data E'KeywordsInImage
  = E'KeywordsInImage'True -- ^ @"true"@
  | E'KeywordsInImage'False -- ^ @"false"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'KeywordsInImage where toJSON = A.toJSON . fromE'KeywordsInImage
instance A.FromJSON E'KeywordsInImage where parseJSON o = P.either P.fail (pure . P.id) . toE'KeywordsInImage =<< A.parseJSON o
instance WH.ToHttpApiData E'KeywordsInImage where toQueryParam = WH.toQueryParam . fromE'KeywordsInImage
instance WH.FromHttpApiData E'KeywordsInImage where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'KeywordsInImage
instance MimeRender MimeMultipartFormData E'KeywordsInImage where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'KeywordsInImage' enum
fromE'KeywordsInImage :: E'KeywordsInImage -> Bool
fromE'KeywordsInImage = \case
  E'KeywordsInImage'True -> "true"
  E'KeywordsInImage'False -> "false"

-- | parse 'E'KeywordsInImage' enum
toE'KeywordsInImage :: Bool -> P.Either String E'KeywordsInImage
toE'KeywordsInImage = \case
  "true" -> P.Right E'KeywordsInImage'True
  "false" -> P.Right E'KeywordsInImage'False
  s -> P.Left $ "toE'KeywordsInImage: enum parse failure: " P.++ P.show s


-- ** E'MediaType

-- | Enum of 'Text'
data E'MediaType
  = E'MediaType'Image -- ^ @"image"@
  | E'MediaType'Video -- ^ @"video"@
  | E'MediaType'Jpg -- ^ @"jpg"@
  | E'MediaType'Gif -- ^ @"gif"@
  | E'MediaType'Png -- ^ @"png"@
  | E'MediaType'Mp4 -- ^ @"mp4"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'MediaType where toJSON = A.toJSON . fromE'MediaType
instance A.FromJSON E'MediaType where parseJSON o = P.either P.fail (pure . P.id) . toE'MediaType =<< A.parseJSON o
instance WH.ToHttpApiData E'MediaType where toQueryParam = WH.toQueryParam . fromE'MediaType
instance WH.FromHttpApiData E'MediaType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'MediaType
instance MimeRender MimeMultipartFormData E'MediaType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'MediaType' enum
fromE'MediaType :: E'MediaType -> Text
fromE'MediaType = \case
  E'MediaType'Image -> "image"
  E'MediaType'Video -> "video"
  E'MediaType'Jpg -> "jpg"
  E'MediaType'Gif -> "gif"
  E'MediaType'Png -> "png"
  E'MediaType'Mp4 -> "mp4"

-- | parse 'E'MediaType' enum
toE'MediaType :: Text -> P.Either String E'MediaType
toE'MediaType = \case
  "image" -> P.Right E'MediaType'Image
  "video" -> P.Right E'MediaType'Video
  "jpg" -> P.Right E'MediaType'Jpg
  "gif" -> P.Right E'MediaType'Gif
  "png" -> P.Right E'MediaType'Png
  "mp4" -> P.Right E'MediaType'Mp4
  s -> P.Left $ "toE'MediaType: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


