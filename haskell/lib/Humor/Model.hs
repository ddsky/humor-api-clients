{-
   Humor API

   Awesome Humor API.

   OpenAPI Version: 3.0.0
   Humor API API version: 1.0
   Contact: mail@humorapi.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Humor.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Humor.Model where

import Humor.Core
import Humor.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ExcludeTags
newtype ExcludeTags = ExcludeTags { unExcludeTags :: E'IncludeTags } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IncludeTags
newtype IncludeTags = IncludeTags { unIncludeTags :: E'IncludeTags } deriving (P.Eq, P.Show)

-- ** Keywords
newtype Keywords = Keywords { unKeywords :: Text } deriving (P.Eq, P.Show)

-- ** KeywordsInImage
newtype KeywordsInImage = KeywordsInImage { unKeywordsInImage :: Bool } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Int } deriving (P.Eq, P.Show)

-- ** MediaType
newtype MediaType = MediaType { unMediaType :: E'MediaType } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Double } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Reason
newtype Reason = Reason { unReason :: Text } deriving (P.Eq, P.Show)

-- ** Word
newtype Word = Word { unWord :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AnalyzeJoke200Response
-- | AnalyzeJoke200Response
-- 
data AnalyzeJoke200Response = AnalyzeJoke200Response
  { analyzeJoke200ResponseJoke :: !(Text) -- ^ /Required/ "joke"
  , analyzeJoke200ResponseTags :: !([Text]) -- ^ /Required/ "tags"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnalyzeJoke200Response
instance A.FromJSON AnalyzeJoke200Response where
  parseJSON = A.withObject "AnalyzeJoke200Response" $ \o ->
    AnalyzeJoke200Response
      <$> (o .:  "joke")
      <*> (o .:  "tags")

-- | ToJSON AnalyzeJoke200Response
instance A.ToJSON AnalyzeJoke200Response where
  toJSON AnalyzeJoke200Response {..} =
   _omitNulls
      [ "joke" .= analyzeJoke200ResponseJoke
      , "tags" .= analyzeJoke200ResponseTags
      ]


-- | Construct a value of type 'AnalyzeJoke200Response' (by applying it's required fields, if any)
mkAnalyzeJoke200Response
  :: Text -- ^ 'analyzeJoke200ResponseJoke' 
  -> [Text] -- ^ 'analyzeJoke200ResponseTags' 
  -> AnalyzeJoke200Response
mkAnalyzeJoke200Response analyzeJoke200ResponseJoke analyzeJoke200ResponseTags =
  AnalyzeJoke200Response
  { analyzeJoke200ResponseJoke
  , analyzeJoke200ResponseTags
  }

-- ** GenerateNonsenseWord200Response
-- | GenerateNonsenseWord200Response
-- 
data GenerateNonsenseWord200Response = GenerateNonsenseWord200Response
  { generateNonsenseWord200ResponseWord :: !(Text) -- ^ /Required/ "word"
  , generateNonsenseWord200ResponseRating :: !(Double) -- ^ /Required/ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateNonsenseWord200Response
instance A.FromJSON GenerateNonsenseWord200Response where
  parseJSON = A.withObject "GenerateNonsenseWord200Response" $ \o ->
    GenerateNonsenseWord200Response
      <$> (o .:  "word")
      <*> (o .:  "rating")

-- | ToJSON GenerateNonsenseWord200Response
instance A.ToJSON GenerateNonsenseWord200Response where
  toJSON GenerateNonsenseWord200Response {..} =
   _omitNulls
      [ "word" .= generateNonsenseWord200ResponseWord
      , "rating" .= generateNonsenseWord200ResponseRating
      ]


-- | Construct a value of type 'GenerateNonsenseWord200Response' (by applying it's required fields, if any)
mkGenerateNonsenseWord200Response
  :: Text -- ^ 'generateNonsenseWord200ResponseWord' 
  -> Double -- ^ 'generateNonsenseWord200ResponseRating' 
  -> GenerateNonsenseWord200Response
mkGenerateNonsenseWord200Response generateNonsenseWord200ResponseWord generateNonsenseWord200ResponseRating =
  GenerateNonsenseWord200Response
  { generateNonsenseWord200ResponseWord
  , generateNonsenseWord200ResponseRating
  }

-- ** Praise200Response
-- | Praise200Response
-- 
data Praise200Response = Praise200Response
  { praise200ResponseText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Praise200Response
instance A.FromJSON Praise200Response where
  parseJSON = A.withObject "Praise200Response" $ \o ->
    Praise200Response
      <$> (o .:  "text")

-- | ToJSON Praise200Response
instance A.ToJSON Praise200Response where
  toJSON Praise200Response {..} =
   _omitNulls
      [ "text" .= praise200ResponseText
      ]


-- | Construct a value of type 'Praise200Response' (by applying it's required fields, if any)
mkPraise200Response
  :: Text -- ^ 'praise200ResponseText' 
  -> Praise200Response
mkPraise200Response praise200ResponseText =
  Praise200Response
  { praise200ResponseText
  }

-- ** RandomJoke200Response
-- | RandomJoke200Response
-- 
data RandomJoke200Response = RandomJoke200Response
  { randomJoke200ResponseId :: !(Int) -- ^ /Required/ "id"
  , randomJoke200ResponseJoke :: !(Text) -- ^ /Required/ "joke"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomJoke200Response
instance A.FromJSON RandomJoke200Response where
  parseJSON = A.withObject "RandomJoke200Response" $ \o ->
    RandomJoke200Response
      <$> (o .:  "id")
      <*> (o .:  "joke")

-- | ToJSON RandomJoke200Response
instance A.ToJSON RandomJoke200Response where
  toJSON RandomJoke200Response {..} =
   _omitNulls
      [ "id" .= randomJoke200ResponseId
      , "joke" .= randomJoke200ResponseJoke
      ]


-- | Construct a value of type 'RandomJoke200Response' (by applying it's required fields, if any)
mkRandomJoke200Response
  :: Int -- ^ 'randomJoke200ResponseId' 
  -> Text -- ^ 'randomJoke200ResponseJoke' 
  -> RandomJoke200Response
mkRandomJoke200Response randomJoke200ResponseId randomJoke200ResponseJoke =
  RandomJoke200Response
  { randomJoke200ResponseId
  , randomJoke200ResponseJoke
  }

-- ** RandomMeme200Response
-- | RandomMeme200Response
-- 
data RandomMeme200Response = RandomMeme200Response
  { randomMeme200ResponseId :: !(Int) -- ^ /Required/ "id"
  , randomMeme200ResponseUrl :: !(Text) -- ^ /Required/ "url"
  , randomMeme200ResponseType :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RandomMeme200Response
instance A.FromJSON RandomMeme200Response where
  parseJSON = A.withObject "RandomMeme200Response" $ \o ->
    RandomMeme200Response
      <$> (o .:  "id")
      <*> (o .:  "url")
      <*> (o .:  "type")

-- | ToJSON RandomMeme200Response
instance A.ToJSON RandomMeme200Response where
  toJSON RandomMeme200Response {..} =
   _omitNulls
      [ "id" .= randomMeme200ResponseId
      , "url" .= randomMeme200ResponseUrl
      , "type" .= randomMeme200ResponseType
      ]


-- | Construct a value of type 'RandomMeme200Response' (by applying it's required fields, if any)
mkRandomMeme200Response
  :: Int -- ^ 'randomMeme200ResponseId' 
  -> Text -- ^ 'randomMeme200ResponseUrl' 
  -> Text -- ^ 'randomMeme200ResponseType' 
  -> RandomMeme200Response
mkRandomMeme200Response randomMeme200ResponseId randomMeme200ResponseUrl randomMeme200ResponseType =
  RandomMeme200Response
  { randomMeme200ResponseId
  , randomMeme200ResponseUrl
  , randomMeme200ResponseType
  }

-- ** RateWord200Response
-- | RateWord200Response
-- 
data RateWord200Response = RateWord200Response
  { rateWord200ResponseRating :: !(Double) -- ^ /Required/ "rating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RateWord200Response
instance A.FromJSON RateWord200Response where
  parseJSON = A.withObject "RateWord200Response" $ \o ->
    RateWord200Response
      <$> (o .:  "rating")

-- | ToJSON RateWord200Response
instance A.ToJSON RateWord200Response where
  toJSON RateWord200Response {..} =
   _omitNulls
      [ "rating" .= rateWord200ResponseRating
      ]


-- | Construct a value of type 'RateWord200Response' (by applying it's required fields, if any)
mkRateWord200Response
  :: Double -- ^ 'rateWord200ResponseRating' 
  -> RateWord200Response
mkRateWord200Response rateWord200ResponseRating =
  RateWord200Response
  { rateWord200ResponseRating
  }

-- ** SearchGifs200Response
-- | SearchGifs200Response
-- 
data SearchGifs200Response = SearchGifs200Response
  { searchGifs200ResponseImages :: !([SearchGifs200ResponseImagesInner]) -- ^ /Required/ "images"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGifs200Response
instance A.FromJSON SearchGifs200Response where
  parseJSON = A.withObject "SearchGifs200Response" $ \o ->
    SearchGifs200Response
      <$> (o .:  "images")

-- | ToJSON SearchGifs200Response
instance A.ToJSON SearchGifs200Response where
  toJSON SearchGifs200Response {..} =
   _omitNulls
      [ "images" .= searchGifs200ResponseImages
      ]


-- | Construct a value of type 'SearchGifs200Response' (by applying it's required fields, if any)
mkSearchGifs200Response
  :: [SearchGifs200ResponseImagesInner] -- ^ 'searchGifs200ResponseImages' 
  -> SearchGifs200Response
mkSearchGifs200Response searchGifs200ResponseImages =
  SearchGifs200Response
  { searchGifs200ResponseImages
  }

-- ** SearchGifs200ResponseImagesInner
-- | SearchGifs200ResponseImagesInner
data SearchGifs200ResponseImagesInner = SearchGifs200ResponseImagesInner
  { searchGifs200ResponseImagesInnerUrl :: !(Text) -- ^ /Required/ "url"
  , searchGifs200ResponseImagesInnerWidth :: !(Int) -- ^ /Required/ "width"
  , searchGifs200ResponseImagesInnerHeight :: !(Int) -- ^ /Required/ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchGifs200ResponseImagesInner
instance A.FromJSON SearchGifs200ResponseImagesInner where
  parseJSON = A.withObject "SearchGifs200ResponseImagesInner" $ \o ->
    SearchGifs200ResponseImagesInner
      <$> (o .:  "url")
      <*> (o .:  "width")
      <*> (o .:  "height")

-- | ToJSON SearchGifs200ResponseImagesInner
instance A.ToJSON SearchGifs200ResponseImagesInner where
  toJSON SearchGifs200ResponseImagesInner {..} =
   _omitNulls
      [ "url" .= searchGifs200ResponseImagesInnerUrl
      , "width" .= searchGifs200ResponseImagesInnerWidth
      , "height" .= searchGifs200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'SearchGifs200ResponseImagesInner' (by applying it's required fields, if any)
mkSearchGifs200ResponseImagesInner
  :: Text -- ^ 'searchGifs200ResponseImagesInnerUrl' 
  -> Int -- ^ 'searchGifs200ResponseImagesInnerWidth' 
  -> Int -- ^ 'searchGifs200ResponseImagesInnerHeight' 
  -> SearchGifs200ResponseImagesInner
mkSearchGifs200ResponseImagesInner searchGifs200ResponseImagesInnerUrl searchGifs200ResponseImagesInnerWidth searchGifs200ResponseImagesInnerHeight =
  SearchGifs200ResponseImagesInner
  { searchGifs200ResponseImagesInnerUrl
  , searchGifs200ResponseImagesInnerWidth
  , searchGifs200ResponseImagesInnerHeight
  }

-- ** SearchJokes200Response
-- | SearchJokes200Response
-- 
data SearchJokes200Response = SearchJokes200Response
  { searchJokes200ResponseJokes :: !([SearchJokes200ResponseJokesInner]) -- ^ /Required/ "jokes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchJokes200Response
instance A.FromJSON SearchJokes200Response where
  parseJSON = A.withObject "SearchJokes200Response" $ \o ->
    SearchJokes200Response
      <$> (o .:  "jokes")

-- | ToJSON SearchJokes200Response
instance A.ToJSON SearchJokes200Response where
  toJSON SearchJokes200Response {..} =
   _omitNulls
      [ "jokes" .= searchJokes200ResponseJokes
      ]


-- | Construct a value of type 'SearchJokes200Response' (by applying it's required fields, if any)
mkSearchJokes200Response
  :: [SearchJokes200ResponseJokesInner] -- ^ 'searchJokes200ResponseJokes' 
  -> SearchJokes200Response
mkSearchJokes200Response searchJokes200ResponseJokes =
  SearchJokes200Response
  { searchJokes200ResponseJokes
  }

-- ** SearchJokes200ResponseJokesInner
-- | SearchJokes200ResponseJokesInner
data SearchJokes200ResponseJokesInner = SearchJokes200ResponseJokesInner
  { searchJokes200ResponseJokesInnerId :: !(Int) -- ^ /Required/ "id"
  , searchJokes200ResponseJokesInnerJoke :: !(Text) -- ^ /Required/ "joke"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchJokes200ResponseJokesInner
instance A.FromJSON SearchJokes200ResponseJokesInner where
  parseJSON = A.withObject "SearchJokes200ResponseJokesInner" $ \o ->
    SearchJokes200ResponseJokesInner
      <$> (o .:  "id")
      <*> (o .:  "joke")

-- | ToJSON SearchJokes200ResponseJokesInner
instance A.ToJSON SearchJokes200ResponseJokesInner where
  toJSON SearchJokes200ResponseJokesInner {..} =
   _omitNulls
      [ "id" .= searchJokes200ResponseJokesInnerId
      , "joke" .= searchJokes200ResponseJokesInnerJoke
      ]


-- | Construct a value of type 'SearchJokes200ResponseJokesInner' (by applying it's required fields, if any)
mkSearchJokes200ResponseJokesInner
  :: Int -- ^ 'searchJokes200ResponseJokesInnerId' 
  -> Text -- ^ 'searchJokes200ResponseJokesInnerJoke' 
  -> SearchJokes200ResponseJokesInner
mkSearchJokes200ResponseJokesInner searchJokes200ResponseJokesInnerId searchJokes200ResponseJokesInnerJoke =
  SearchJokes200ResponseJokesInner
  { searchJokes200ResponseJokesInnerId
  , searchJokes200ResponseJokesInnerJoke
  }

-- ** SearchMemes200Response
-- | SearchMemes200Response
-- 
data SearchMemes200Response = SearchMemes200Response
  { searchMemes200ResponseMemes :: !([SearchMemes200ResponseMemesInner]) -- ^ /Required/ "memes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMemes200Response
instance A.FromJSON SearchMemes200Response where
  parseJSON = A.withObject "SearchMemes200Response" $ \o ->
    SearchMemes200Response
      <$> (o .:  "memes")

-- | ToJSON SearchMemes200Response
instance A.ToJSON SearchMemes200Response where
  toJSON SearchMemes200Response {..} =
   _omitNulls
      [ "memes" .= searchMemes200ResponseMemes
      ]


-- | Construct a value of type 'SearchMemes200Response' (by applying it's required fields, if any)
mkSearchMemes200Response
  :: [SearchMemes200ResponseMemesInner] -- ^ 'searchMemes200ResponseMemes' 
  -> SearchMemes200Response
mkSearchMemes200Response searchMemes200ResponseMemes =
  SearchMemes200Response
  { searchMemes200ResponseMemes
  }

-- ** SearchMemes200ResponseMemesInner
-- | SearchMemes200ResponseMemesInner
data SearchMemes200ResponseMemesInner = SearchMemes200ResponseMemesInner
  { searchMemes200ResponseMemesInnerId :: !(Int) -- ^ /Required/ "id"
  , searchMemes200ResponseMemesInnerUrl :: !(Text) -- ^ /Required/ "url"
  , searchMemes200ResponseMemesInnerType :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchMemes200ResponseMemesInner
instance A.FromJSON SearchMemes200ResponseMemesInner where
  parseJSON = A.withObject "SearchMemes200ResponseMemesInner" $ \o ->
    SearchMemes200ResponseMemesInner
      <$> (o .:  "id")
      <*> (o .:  "url")
      <*> (o .:  "type")

-- | ToJSON SearchMemes200ResponseMemesInner
instance A.ToJSON SearchMemes200ResponseMemesInner where
  toJSON SearchMemes200ResponseMemesInner {..} =
   _omitNulls
      [ "id" .= searchMemes200ResponseMemesInnerId
      , "url" .= searchMemes200ResponseMemesInnerUrl
      , "type" .= searchMemes200ResponseMemesInnerType
      ]


-- | Construct a value of type 'SearchMemes200ResponseMemesInner' (by applying it's required fields, if any)
mkSearchMemes200ResponseMemesInner
  :: Int -- ^ 'searchMemes200ResponseMemesInnerId' 
  -> Text -- ^ 'searchMemes200ResponseMemesInnerUrl' 
  -> Text -- ^ 'searchMemes200ResponseMemesInnerType' 
  -> SearchMemes200ResponseMemesInner
mkSearchMemes200ResponseMemesInner searchMemes200ResponseMemesInnerId searchMemes200ResponseMemesInnerUrl searchMemes200ResponseMemesInnerType =
  SearchMemes200ResponseMemesInner
  { searchMemes200ResponseMemesInnerId
  , searchMemes200ResponseMemesInnerUrl
  , searchMemes200ResponseMemesInnerType
  }

-- ** SubmitJoke200Response
-- | SubmitJoke200Response
-- 
data SubmitJoke200Response = SubmitJoke200Response
  { submitJoke200ResponseMessage :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubmitJoke200Response
instance A.FromJSON SubmitJoke200Response where
  parseJSON = A.withObject "SubmitJoke200Response" $ \o ->
    SubmitJoke200Response
      <$> (o .:  "message")

-- | ToJSON SubmitJoke200Response
instance A.ToJSON SubmitJoke200Response where
  toJSON SubmitJoke200Response {..} =
   _omitNulls
      [ "message" .= submitJoke200ResponseMessage
      ]


-- | Construct a value of type 'SubmitJoke200Response' (by applying it's required fields, if any)
mkSubmitJoke200Response
  :: Text -- ^ 'submitJoke200ResponseMessage' 
  -> SubmitJoke200Response
mkSubmitJoke200Response submitJoke200ResponseMessage =
  SubmitJoke200Response
  { submitJoke200ResponseMessage
  }


-- * Enums


-- ** E'IncludeTags

-- | Enum of 'Text'
data E'IncludeTags
  = E'IncludeTags'Clean -- ^ @"clean"@
  | E'IncludeTags'Yo_mama -- ^ @"yo_mama"@
  | E'IncludeTags'Chuck_norris -- ^ @"chuck_norris"@
  | E'IncludeTags'Nsfw -- ^ @"nsfw"@
  | E'IncludeTags'Racist -- ^ @"racist"@
  | E'IncludeTags'Sexist -- ^ @"sexist"@
  | E'IncludeTags'Sexual -- ^ @"sexual"@
  | E'IncludeTags'Political -- ^ @"political"@
  | E'IncludeTags'Religious -- ^ @"religious"@
  | E'IncludeTags'Knock_knock -- ^ @"knock_knock"@
  | E'IncludeTags'Christmas -- ^ @"christmas"@
  | E'IncludeTags'Nerdy -- ^ @"nerdy"@
  | E'IncludeTags'Analogy -- ^ @"analogy"@
  | E'IncludeTags'One_liner -- ^ @"one_liner"@
  | E'IncludeTags'Dark -- ^ @"dark"@
  | E'IncludeTags'Jewish -- ^ @"jewish"@
  | E'IncludeTags'School -- ^ @"school"@
  | E'IncludeTags'Sport -- ^ @"sport"@
  | E'IncludeTags'Law -- ^ @"law"@
  | E'IncludeTags'Kids -- ^ @"kids"@
  | E'IncludeTags'Animal -- ^ @"animal"@
  | E'IncludeTags'Relationship -- ^ @"relationship"@
  | E'IncludeTags'Insults -- ^ @"insults"@
  | E'IncludeTags'Blondes -- ^ @"blondes"@
  | E'IncludeTags'Deep_thoughts -- ^ @"deep_thoughts"@
  | E'IncludeTags'Food -- ^ @"food"@
  | E'IncludeTags'Holiday -- ^ @"holiday"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'IncludeTags where toJSON = A.toJSON . fromE'IncludeTags
instance A.FromJSON E'IncludeTags where parseJSON o = P.either P.fail (pure . P.id) . toE'IncludeTags =<< A.parseJSON o
instance WH.ToHttpApiData E'IncludeTags where toQueryParam = WH.toQueryParam . fromE'IncludeTags
instance WH.FromHttpApiData E'IncludeTags where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'IncludeTags
instance MimeRender MimeMultipartFormData E'IncludeTags where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'IncludeTags' enum
fromE'IncludeTags :: E'IncludeTags -> Text
fromE'IncludeTags = \case
  E'IncludeTags'Clean -> "clean"
  E'IncludeTags'Yo_mama -> "yo_mama"
  E'IncludeTags'Chuck_norris -> "chuck_norris"
  E'IncludeTags'Nsfw -> "nsfw"
  E'IncludeTags'Racist -> "racist"
  E'IncludeTags'Sexist -> "sexist"
  E'IncludeTags'Sexual -> "sexual"
  E'IncludeTags'Political -> "political"
  E'IncludeTags'Religious -> "religious"
  E'IncludeTags'Knock_knock -> "knock_knock"
  E'IncludeTags'Christmas -> "christmas"
  E'IncludeTags'Nerdy -> "nerdy"
  E'IncludeTags'Analogy -> "analogy"
  E'IncludeTags'One_liner -> "one_liner"
  E'IncludeTags'Dark -> "dark"
  E'IncludeTags'Jewish -> "jewish"
  E'IncludeTags'School -> "school"
  E'IncludeTags'Sport -> "sport"
  E'IncludeTags'Law -> "law"
  E'IncludeTags'Kids -> "kids"
  E'IncludeTags'Animal -> "animal"
  E'IncludeTags'Relationship -> "relationship"
  E'IncludeTags'Insults -> "insults"
  E'IncludeTags'Blondes -> "blondes"
  E'IncludeTags'Deep_thoughts -> "deep_thoughts"
  E'IncludeTags'Food -> "food"
  E'IncludeTags'Holiday -> "holiday"

-- | parse 'E'IncludeTags' enum
toE'IncludeTags :: Text -> P.Either String E'IncludeTags
toE'IncludeTags = \case
  "clean" -> P.Right E'IncludeTags'Clean
  "yo_mama" -> P.Right E'IncludeTags'Yo_mama
  "chuck_norris" -> P.Right E'IncludeTags'Chuck_norris
  "nsfw" -> P.Right E'IncludeTags'Nsfw
  "racist" -> P.Right E'IncludeTags'Racist
  "sexist" -> P.Right E'IncludeTags'Sexist
  "sexual" -> P.Right E'IncludeTags'Sexual
  "political" -> P.Right E'IncludeTags'Political
  "religious" -> P.Right E'IncludeTags'Religious
  "knock_knock" -> P.Right E'IncludeTags'Knock_knock
  "christmas" -> P.Right E'IncludeTags'Christmas
  "nerdy" -> P.Right E'IncludeTags'Nerdy
  "analogy" -> P.Right E'IncludeTags'Analogy
  "one_liner" -> P.Right E'IncludeTags'One_liner
  "dark" -> P.Right E'IncludeTags'Dark
  "jewish" -> P.Right E'IncludeTags'Jewish
  "school" -> P.Right E'IncludeTags'School
  "sport" -> P.Right E'IncludeTags'Sport
  "law" -> P.Right E'IncludeTags'Law
  "kids" -> P.Right E'IncludeTags'Kids
  "animal" -> P.Right E'IncludeTags'Animal
  "relationship" -> P.Right E'IncludeTags'Relationship
  "insults" -> P.Right E'IncludeTags'Insults
  "blondes" -> P.Right E'IncludeTags'Blondes
  "deep_thoughts" -> P.Right E'IncludeTags'Deep_thoughts
  "food" -> P.Right E'IncludeTags'Food
  "holiday" -> P.Right E'IncludeTags'Holiday
  s -> P.Left $ "toE'IncludeTags: enum parse failure: " P.++ P.show s


-- ** E'MediaType

-- | Enum of 'Text'
data E'MediaType
  = E'MediaType'Image -- ^ @"image"@
  | E'MediaType'Video -- ^ @"video"@
  | E'MediaType'Jpg -- ^ @"jpg"@
  | E'MediaType'Gif -- ^ @"gif"@
  | E'MediaType'Png -- ^ @"png"@
  | E'MediaType'Mp4 -- ^ @"mp4"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'MediaType where toJSON = A.toJSON . fromE'MediaType
instance A.FromJSON E'MediaType where parseJSON o = P.either P.fail (pure . P.id) . toE'MediaType =<< A.parseJSON o
instance WH.ToHttpApiData E'MediaType where toQueryParam = WH.toQueryParam . fromE'MediaType
instance WH.FromHttpApiData E'MediaType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'MediaType
instance MimeRender MimeMultipartFormData E'MediaType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'MediaType' enum
fromE'MediaType :: E'MediaType -> Text
fromE'MediaType = \case
  E'MediaType'Image -> "image"
  E'MediaType'Video -> "video"
  E'MediaType'Jpg -> "jpg"
  E'MediaType'Gif -> "gif"
  E'MediaType'Png -> "png"
  E'MediaType'Mp4 -> "mp4"

-- | parse 'E'MediaType' enum
toE'MediaType :: Text -> P.Either String E'MediaType
toE'MediaType = \case
  "image" -> P.Right E'MediaType'Image
  "video" -> P.Right E'MediaType'Video
  "jpg" -> P.Right E'MediaType'Jpg
  "gif" -> P.Right E'MediaType'Gif
  "png" -> P.Right E'MediaType'Png
  "mp4" -> P.Right E'MediaType'Mp4
  s -> P.Left $ "toE'MediaType: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


